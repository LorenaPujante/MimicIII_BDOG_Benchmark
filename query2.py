
class Query2:

    def __init__(self, idBact, idPat, dateStart, dateEnd):
        self.idBact = idBact
        self.idPat = idPat
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.dateStart_n4j = dateStart + "Z"
        self.dateEnd_n4j = dateEnd + "Z"
        
        

    #########
    # NEO4J #
    #########
    def getQuery_neo4j(self):
        query = ""
        query += "WITH datetime(\"{}\") AS dateStart, datetime(\"{}\") AS dateEnd\n".format(self.dateStart_n4j, self.dateEnd_n4j)
        query += "MATCH (m:Microorganism {{id: {}}})\n".format(self.idBact)
        query += "MATCH (p:Patient {{id: {}}})<-[:episodeFromPatient]-(:Episode)<-[:eventFromEpisode]-(ev:Event)-[:hasLocation]->(s:Seat)\n".format(self.idPat)
        query += "WHERE ((ev.start >= dateStart AND ev.end <= dateEnd)  \n"
        query += "OR (ev.start <= dateStart AND ev.end >= dateStart)  \n"
        query += "OR (ev.start <= dateEnd AND ev.end >= dateEnd)) \n"
        query += "MATCH path1a = (s)-[:placedIn*0..3]->(l:Location) \n"
        query += "WITH MAX(length(path1a)) AS maxLength,  \n"
        query += "p,m,s,ev, dateStart,dateEnd \n"
        query += "MATCH path1a = (s)-[:placedIn*0..3]->(l:Location) \n"
        query += "WHERE length(path1a) = maxLength \n"
        query += "OPTIONAL MATCH (l)<-[:hasArea]-(lz:LogicZone)-[:hasArea]->(ar2) \n"
        query += "OPTIONAL MATCH (s)-[:placedIn]->(r1:Room)-[:nextTo]-(r2:Room) \n"
        query += "WHERE NOT EXISTS ((s)-[:placedIn*2..3]->(:Location)<-[:placedIn*1..2]-(r2)) \n"
        query += "OPTIONAL MATCH (ev)-[:hasHospUnit]->(hu:HospitalizationUnit) \n"
        query += "WITH p,m, dateStart,dateEnd, \n"
        query += "apoc.coll.toSet(collect(l) + collect(ar2) + collect(r2) + collect(hu)) AS things \n"
        query += "UNWIND things AS t \n"
        query += "OPTIONAL MATCH (t)<-[:placedIn*0..3]-(l2:Seat)<-[:hasLocation]-(ev2:Event)-[:eventFromEpisode]->(ep2:Episode)-[:episodeFromPatient]->(p2:Patient) \n"
        query += "WHERE p2<>p \n"
        query += "AND ((ev2.start >= dateStart AND ev2.end <= dateEnd)  \n"
        query += "OR (ev2.start <= dateStart AND ev2.end >= dateStart)  \n"
        query += "OR (ev2.start <= dateEnd AND ev2.end >= dateEnd)) \n"
        query += "OPTIONAL MATCH (t)<-[:hasHospUnit]-(ev3:Event)-[:eventFromEpisode]->(ep3:Episode)-[:episodeFromPatient]->(p3:Patient) \n"
        query += "WHERE p3<>p \n"
        query += "AND ((ev3.start >= dateStart AND ev3.end <= dateEnd)  \n"
        query += "OR (ev3.start <= dateStart AND ev3.end >= dateStart)  \n"
        query += "OR (ev3.start <= dateEnd AND ev3.end >= dateEnd)) \n"
        query += "WITH p,m, dateStart,dateEnd, \n"
        query += "apoc.coll.toSet(collect({p2: p2, ep2:ep2}) + collect({p2: p3, ep2:ep3})) AS pats \n"
        query += "UNWIND pats AS pat \n"
        query += "MATCH (ep2:Episode {id:pat.ep2.id})<-[:eventFromEpisode]-(tm2:TestMicro)-[:hasFound]->(m) \n"
        query += "WHERE (tm2.start >= dateStart AND tm2.end <= dateEnd) \n"
        query += "RETURN DISTINCT pat.p2 \n"
        
        return query


    def getQuery_paths_neo4j(self):
        query = ""
        query += "WITH datetime(\"{}\") AS dateStart, datetime(\"{}\") AS dateEnd\n".format(self.dateStart_n4j, self.dateEnd_n4j)
        query += "MATCH (m:Microorganism {{id: {}}})\n".format(self.idBact)
        query += "MATCH path0 = (p:Patient {{id: {}}})<-[:episodeFromPatient]-(:Episode)<-[:eventFromEpisode]-(ev:Event)-[:hasLocation]->(s:Seat)\n".format(self.idPat)
        query += "WHERE ((ev.start >= dateStart AND ev.end <= dateEnd)  \n"
        query += "OR (ev.start <= dateStart AND ev.end >= dateStart)  \n"
        query += "OR (ev.start <= dateEnd AND ev.end >= dateEnd)) \n"
        query += "MATCH path1a = (s)-[:placedIn*0..3]->(l:Location) \n"
        query += "WITH MAX(length(path1a)) AS maxLength,  \n"
        query += "p,m,s,ev, dateStart,dateEnd,  \n"
        query += "path0 \n"
        query += "MATCH path1a = (s)-[:placedIn*0..3]->(l:Location) \n"
        query += "WHERE length(path1a) = maxLength \n"
        query += "OPTIONAL MATCH path1b = (l)<-[:hasArea]-(lz:LogicZone)-[:hasArea]->(ar2) \n"
        query += "OPTIONAL MATCH path1c = (s)-[:placedIn]->(r1:Room)-[:nextTo]-(r2:Room) \n"
        query += "WHERE NOT EXISTS ((s)-[:placedIn*2..3]->(:Location)<-[:placedIn*1..2]-(r2)) \n"
        query += "OPTIONAL MATCH path1d = (ev)-[:hasHospUnit]->(hu:HospitalizationUnit) \n"
        query += "WITH p,m, dateStart,dateEnd, \n"
        query += "apoc.coll.toSet(collect(l) + collect(ar2) + collect(r2) + collect(hu)) AS things, \n"
        query += "collect({path0:path0, path1a:path1a, path1c:path1c, path1b:path1b, path1d:path1d}) AS pathsInit \n"
        query += "UNWIND things AS t \n"
        query += "OPTIONAL MATCH path2a = (t)<-[:placedIn*0..3]-(l2:Seat)<-[:hasLocation]-(ev2:Event)-[:eventFromEpisode]->(ep2:Episode)-[:episodeFromPatient]->(p2:Patient) \n"
        query += "WHERE p2<>p \n"
        query += "AND ((ev2.start >= dateStart AND ev2.end <= dateEnd)  \n"
        query += "OR (ev2.start <= dateStart AND ev2.end >= dateStart)  \n"
        query += "OR (ev2.start <= dateEnd AND ev2.end >= dateEnd)) \n"
        query += "OPTIONAL MATCH path2b = (t)<-[:hasHospUnit]-(ev3:Event)-[:eventFromEpisode]->(ep3:Episode)-[:episodeFromPatient]->(p3:Patient) \n"
        query += "WHERE p3<>p \n"
        query += "AND ((ev3.start >= dateStart AND ev3.end <= dateEnd)  \n"
        query += "OR (ev3.start <= dateStart AND ev3.end >= dateStart)  \n"
        query += "OR (ev3.start <= dateEnd AND ev3.end >= dateEnd)) \n"
        query += "WITH p,m, dateStart,dateEnd, \n"
        query += "pathsInit, \n"
        query += "collect({path2a:path2a, path2b:path2b}) AS pathsEnd, \n"
        query += "apoc.coll.toSet(collect({p2: p2, ep2:ep2}) + collect({p2: p3, ep2:ep3})) AS pats \n"
        query += "UNWIND pats AS pat \n"
        query += "MATCH path3 = (ep2:Episode {id:pat.ep2.id})<-[:eventFromEpisode]-(tm2:TestMicro)-[:hasFound]->(m) \n"
        query += "WHERE (tm2.start >= dateStart AND tm2.end <= dateEnd) \n"
        query += "WITH pathsInit, pathsEnd, \n"
        query += "collect(path3) AS pathsMicro, \n"
        query += "collect(DISTINCT pat.p2) AS pats \n"
        query += "RETURN pats, pathsInit, pathsEnd, pathsMicro \n"

        return query
    


    ##########
    # SPARQL #
    ##########
    def getQuery_sparql(self):
        query = "PREFIX ho: <http://www.semanticweb.org/spatiotemporalHospitalOntology#>\n"
        query += "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n"
        query += "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n"
        query += "SELECT DISTINCT ?p\n"
        query += "{\n"
        query += "VALUES (?start ?end) {{(\"{}\"^^xsd:dateTime \"{}\"^^xsd:dateTime)}}\n".format(self.dateStart, self.dateEnd)
        query += "VALUES (?m_id ?p1_id) {{({} {})}}\n".format(self.idBact, self.idPat)
        query += "?p1 a ho:Patient;\n"
        query += "ho:id ?p1_id .\n"
        query += "?ev1 ho:eventFromEpisode/ho:episodeFromPatient ?p1;\n"
        query += "ho:start ?ev1_start;\n"
        query += "ho:end ?ev1_end;\n"
        query += "ho:hasLocation ?bed1.\n"
        query += "?m a ho:Microorganism;\n"
        query += "ho:id ?m_id .\n"
        query += "?m ^(ho:hasFound2)/ho:hasFound1 ?tm.\n"
        query += "?tm ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?tm_start;\n"
        query += "ho:end ?tm_end.\n"
        query += "?ep ho:episodeFromPatient ?p .\n"
        query += "?ev ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?ev_start;\n"
        query += "ho:end ?ev_end;\n"
        query += "ho:hasLocation ?bed.\n"
        query += "OPTIONAL {\n"
        query += "?bed1 (^(ho:placedIn1)/ho:placedIn2)* ?mid.\n"
        query += "?mid (^(ho:placedIn2)/ho:placedIn1)* ?bed.\n"
        query += "FILTER (!regex(str(?mid), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "}\n"
        query += "?bed1 ^(ho:placedIn1)/ho:placedIn2 ?room1.\n"
        query += "?bed ^(ho:placedIn1)/ho:placedIn2 ?room.\n"
        query += "OPTIONAL {\n"
        query += "?nx (ho:nextTo1|ho:nextTo2) ?room1.\n"
        query += "?nx (ho:nextTo1|ho:nextTo2) ?room.\n"
        query += "OPTIONAL {?room1 (^ho:placedIn1/ho:placedIn2)+ ?area1.\n"
        query += "?area1 a ho:Area.}\n"
        query += "OPTIONAL {?room (^ho:placedIn1/ho:placedIn2)+ ?area.\n"
        query += "?area a ho:Area.}\n"
        query += "FILTER(?area1 != ?area  ||  (isBlank(?area1) && isBlank(?area)))\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?room1 (^(ho:placedIn1)/ho:placedIn2)+ ?area1.\n"
        query += "?area1 a ho:Area.\n"
        query += "?room (^(ho:placedIn1)/ho:placedIn2)+ ?area.\n"
        query += "?area a ho:Area.\n"
        query += "?area1 ^(ho:hasArea2)/ho:hasArea1 ?lz.\n"
        query += "?area ^(ho:hasArea2)/ho:hasArea1 ?lz.\n"
        query += "FILTER(?area1 != ?area)\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?ev1 ho:hasHospUnit ?huA.\n"
        query += "?ev ho:hasHospUnit ?huA.\n"
        query += "}\n"
        query += "FILTER(!isBlank(?nx)  ||  !isBlank(?mid)  ||  !isBlank(?lz)  ||  !isBlank(?huA))\n"
        query += "FILTER(?p != ?p1)\n"
        query += "FILTER((?tm_start >= ?start) && (?tm_end <= ?end))\n"
        query += "FILTER((?ev_start >= ?start && ?ev_end <= ?end) \n"
        query += "|| (?ev_start <= ?start && ?ev_end >= ?start) \n"
        query += "|| (?ev_start <= ?end && ?ev_end >= ?end))\n"
        query += "FILTER((?ev1_start >= ?start && ?ev1_end <= ?end) \n"
        query += "|| (?ev1_start <= ?start && ?ev1_end >= ?start) \n"
        query += "|| (?ev1_start <= ?end && ?ev1_end >= ?end))\n"
        query += "}"

        return query


    def getQuery_paths_sparql(self):
        query = "PREFIX ho: <http://www.semanticweb.org/spatiotemporalHospitalOntology#>\n"
        query += "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n"
        query += "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n"
        query += "SELECT DISTINCT ?p ?ep1 ?ev1 ?ep ?ev ?tm ?huA ?bed1 ?bed ?room1 ?room ?nx ?area1 ?area ?lz ?pathToMiddleLoc ?pathToMiddleLoc2\n"
        query += "{\n"
        query += "{\n"
        query += "VALUES (?start ?end) {{(\"{}\"^^xsd:dateTime \"{}\"^^xsd:dateTime)}}\n".format(self.dateStart, self.dateEnd)
        query += "VALUES (?m_id ?p1_id) {{({} {})}}\n".format(self.idBact, self.idPat)
        query += "?p1 a ho:Patient;\n"
        query += "ho:id ?p1_id .\n"
        query += "?ev1 ho:eventFromEpisode ?ep1;\n"
        query += "ho:start ?ev1_start;\n"
        query += "ho:end ?ev1_end;\n"
        query += "ho:hasLocation ?bed1.\n"
        query += "?ep1 ho:episodeFromPatient ?p1.\n"
        query += "?m a ho:Microorganism;\n"
        query += "ho:id ?m_id .\n"
        query += "?m ^(ho:hasFound2)/ho:hasFound1 ?tm.\n"
        query += "?tm ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?tm_start;\n"
        query += "ho:end ?tm_end.\n"
        query += "?ep ho:episodeFromPatient ?p .\n"
        query += "?ev ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?ev_start;\n"
        query += "ho:end ?ev_end;\n"
        query += "ho:hasLocation ?bed.\n"
        query += "?bed1 ^(ho:placedIn1)/ho:placedIn2 ?room1.\n"
        query += "?bed ^(ho:placedIn1)/ho:placedIn2 ?room.\n"
        query += "OPTIONAL {\n"
        query += "?bed1 (^(ho:placedIn1)/ho:placedIn2)* ?mid.\n"
        query += "?mid (^(ho:placedIn2)/ho:placedIn1)* ?bed.\n"
        query += "FILTER (!regex(str(?mid), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?nx (ho:nextTo1|ho:nextTo2) ?room1.\n"
        query += "?nx (ho:nextTo1|ho:nextTo2) ?room.\n"
        query += "OPTIONAL {?room1 (^ho:placedIn1/ho:placedIn2)+ ?area1.\n"
        query += "?area1 a ho:Area.}\n"
        query += "OPTIONAL {?room (^ho:placedIn1/ho:placedIn2)+ ?area.\n"
        query += "?area a ho:Area.}\n"
        query += "FILTER(?area1 != ?area  ||  (isBlank(?area1) && isBlank(?area)))\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?room1 (^(ho:placedIn1)/ho:placedIn2)+ ?area1.\n"
        query += "?area1 a ho:Area.\n"
        query += "?room (^(ho:placedIn1)/ho:placedIn2)+ ?area.\n"
        query += "?area a ho:Area.\n"
        query += "?area1 ^(ho:hasArea2)/ho:hasArea1 ?lz.\n"
        query += "?area ^(ho:hasArea2)/ho:hasArea1 ?lz.\n"
        query += "FILTER(?area1 != ?area)\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?ev1 ho:hasHospUnit ?huA.\n"
        query += "?ev ho:hasHospUnit ?huA.\n"
        query += "}\n"
        query += "FILTER(!isBlank(?mid)  ||  !isBlank(?nx)  ||  !isBlank(?lz)  ||  !isBlank(?huA))\n"
        query += "FILTER(?p != ?p1)\n"
        query += "FILTER((?tm_start >= ?start) && (?tm_end <= ?end))\n"
        query += "FILTER((?ev_start >= ?start && ?ev_end <= ?end)\n"
        query += "|| (?ev_start <= ?start && ?ev_end >= ?start)\n"
        query += "|| (?ev_start <= ?end && ?ev_end >= ?end))\n"
        query += "FILTER((?ev1_start >= ?start && ?ev1_end <= ?end)\n"
        query += "|| (?ev1_start <= ?start && ?ev1_end >= ?start)\n"
        query += "|| (?ev1_start <= ?end && ?ev1_end >= ?end))\n"
        query += "}\n"
        query += "UNION\n"
        query += "{\n"
        query += "SELECT ?bed1 ?bed (group_concat(DISTINCT ?mid; separator=\", \") AS ?pathToMiddleLoc) (group_concat(DISTINCT ?mid2; separator=\", \") AS ?pathToMiddleLoc2)\n"
        query += "{\n"
        query += "{\n"
        query += "SELECT DISTINCT ?bed ?bed1 {\n"
        query += "VALUES (?start ?end) {{(\"{}\"^^xsd:dateTime \"{}\"^^xsd:dateTime)}}\n".format(self.dateStart, self.dateEnd)
        query += "VALUES (?m_id ?p1_id) {{({} {})}}\n".format(self.idBact, self.idPat)
        query += "?p1 a ho:Patient;\n"
        query += "ho:id ?p1_id .\n"
        query += "?ev1 ho:eventFromEpisode ?ep1;\n"
        query += "ho:start ?ev1_start;\n"
        query += "ho:end ?ev1_end;\n"
        query += "ho:hasLocation ?bed1.\n"
        query += "?ep1 ho:episodeFromPatient ?p1.\n"
        query += "?m a ho:Microorganism;\n"
        query += "ho:id ?m_id .\n"
        query += "?m ^(ho:hasFound2)/ho:hasFound1 ?tm.\n"
        query += "?tm ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?tm_start;\n"
        query += "ho:end ?tm_end.\n"
        query += "?ep ho:episodeFromPatient ?p .\n"
        query += "?ev ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?ev_start;\n"
        query += "ho:end ?ev_end;\n"
        query += "ho:hasLocation ?bed.\n"
        query += "FILTER(?p != ?p1)\n"
        query += "FILTER((?tm_start >= ?start) && (?tm_end <= ?end))\n"
        query += "FILTER((?ev_start >= ?start && ?ev_end <= ?end)\n"
        query += "|| (?ev_start <= ?start && ?ev_end >= ?start)\n"
        query += "|| (?ev_start <= ?end && ?ev_end >= ?end))\n"
        query += "FILTER((?ev1_start >= ?start && ?ev1_end <= ?end)\n"
        query += "|| (?ev1_start <= ?start && ?ev1_end >= ?start)\n"
        query += "|| (?ev1_start <= ?end && ?ev1_end >= ?end))\n"
        query += "}\n"
        query += "}\n"
        query += "?bed1 (^(ho:placedIn1)/ho:placedIn2)* ?mid.\n"
        query += "?mid (^(ho:placedIn1)/ho:placedIn2)* ?midAux.\n"
        query += "?midAux (^(ho:placedIn2)/ho:placedIn1)+ ?mid2.\n"
        query += "?mid2 (^(ho:placedIn2)/ho:placedIn1)* ?bed.\n"
        query += "FILTER (!regex(str(?mid), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "FILTER (!regex(str(?midAux), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "} GROUP BY ?bed ?bed1\n"
        query += "}\n"
        query += "}\n"

        return query



    ###############
    # SPARQL-STAR #
    ###############
    def getQuery_sparqlStar(self):
        query = "PREFIX ho: <http://www.semanticweb.org/spatiotemporalHospitalOntology#>\n"
        query += "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n"
        query += "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n"
        query += "SELECT DISTINCT ?p\n"
        query += "{\n"
        query += "VALUES (?start ?end) {{(\"{}\"^^xsd:dateTime \"{}\"^^xsd:dateTime)}}\n".format(self.dateStart, self.dateEnd, self.idBact, self.idPat)
        query += "VALUES (?m_id ?p1_id) {{({} {})}}\n".format(self.idBact, self.idPat)
        query += "?p1 a ho:Patient;\n"
        query += "ho:id ?p1_id .\n"
        query += "?ev1 ho:eventFromEpisode/ho:episodeFromPatient ?p1;\n"
        query += "ho:start ?ev1_start;\n"
        query += "ho:end ?ev1_end;\n"
        query += "ho:hasLocation ?bed1.\n"
        query += "?m a ho:Microorganism;\n"
        query += "ho:id ?m_id .\n"
        query += "?m ^ho:hasFound ?tm.\n"
        query += "?tm ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?tm_start;\n"
        query += "ho:end ?tm_end.\n"
        query += "?ep ho:episodeFromPatient ?p .\n"
        query += "?ev ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?ev_start;\n"
        query += "ho:end ?ev_end;\n"
        query += "ho:hasLocation ?bed.\n"
        query += "OPTIONAL {\n"
        query += "?bed1 ho:placedIn* ?mid.\n"
        query += "?mid (^ho:placedIn)* ?bed.\n"
        query += "FILTER (!regex(str(?mid), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "}\n"
        query += "?bed1 ho:placedIn ?room1.\n"
        query += "?bed ho:placedIn ?room.\n"
        query += "OPTIONAL {\n"
        query += "?bed ho:placedIn ?room.\n"
        query += "?bed1 ho:placedIn ?room1.\n"
        query += "OPTIONAL {?room ?relNX1 ?room1.\n"
        query += "FILTER((str(?relNX1) = \"http://www.semanticweb.org/spatiotemporalHospitalOntology#nextTo\"))}\n"
        query += "OPTIONAL {?room1 ?relNX2 ?room.\n"
        query += "FILTER((str(?relNX2) = \"http://www.semanticweb.org/spatiotemporalHospitalOntology#nextTo\"))}\n"
        query += "OPTIONAL {?room1 ho:placedIn+ ?area1.\n"
        query += "?area1 a ho:Area.}\n"
        query += "OPTIONAL {?room (ho:placedIn)+ ?area.\n"
        query += "?area a ho:Area.}\n"
        query += "FILTER(?area1 != ?area  ||  (isBlank(?area1) && isBlank(?area)))\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?room1 ho:placedIn+ ?area1.\n"
        query += "?area1 a ho:Area.\n"
        query += "?room ho:placedIn+ ?area.\n"
        query += "?area a ho:Area.\n"
        query += "?area1 ^ho:hasArea ?lz.\n"
        query += "?area ^ho:hasArea ?lz.\n"
        query += "FILTER(?area1 != ?area)\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?ev1 ho:hasHospUnit ?huA.\n"
        query += "?ev ho:hasHospUnit ?huA.\n"
        query += "}\n"
        query += "FILTER(!isBlank(?relNX1)  ||  !isBlank(?relNX2)  ||  !isBlank(?mid)  ||  !isBlank(?lz)  ||  !isBlank(?huA))\n"
        query += "FILTER(?p != ?p1)\n"
        query += "FILTER((?tm_start >= ?start) && (?tm_end <= ?end))\n"
        query += "FILTER((?ev_start >= ?start && ?ev_end <= ?end) \n"
        query += "|| (?ev_start <= ?start && ?ev_end >= ?start) \n"
        query += "|| (?ev_start <= ?end && ?ev_end >= ?end))\n"
        query += "FILTER((?ev1_start >= ?start && ?ev1_end <= ?end) \n"
        query += "|| (?ev1_start <= ?start && ?ev1_end >= ?start) \n"
        query += "|| (?ev1_start <= ?end && ?ev1_end >= ?end))\n"
        query += "}"

        return query


    def getQuery_paths_sparqlStar(self):
        query = "PREFIX ho: <http://www.semanticweb.org/spatiotemporalHospitalOntology#>\n"
        query += "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n"
        query += "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n"
        query += "SELECT DISTINCT ?p ?ep1 ?ev1 ?ep ?ev ?huA ?bed1 ?bed ?room1 ?room ?relNX1 ?relNX2 ?area1 ?area ?lz ?pathToMiddleLoc ?pathToMiddleLoc2\n"
        query += "{\n"
        query += "{\n"
        query += "VALUES (?start ?end) {{(\"{}\"^^xsd:dateTime \"{}\"^^xsd:dateTime)}}\n".format(self.dateStart, self.dateEnd)
        query += "VALUES (?m_id ?p1_id) {{({} {})}}\n".format(self.idBact, self.idPat)
        query += "?p1 a ho:Patient;\n"
        query += "ho:id ?p1_id .\n"
        query += "?ev1 ho:eventFromEpisode ?ep1;\n"
        query += "ho:start ?ev1_start;\n"
        query += "ho:end ?ev1_end;\n"
        query += "ho:hasLocation ?bed1.\n"
        query += "?ep1 ho:episodeFromPatient ?p1.\n"
        query += "?m a ho:Microorganism;\n"
        query += "ho:id ?m_id .\n"
        query += "?tm ho:hasFound ?m;\n"
        query += "ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?tm_start;\n"
        query += "ho:end ?tm_end.\n"
        query += "?ep ho:episodeFromPatient ?p .\n"
        query += "?ev ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?ev_start;\n"
        query += "ho:end ?ev_end;\n"
        query += "ho:hasLocation ?bed.\n"
        query += "?bed1 ho:placedIn ?room1.\n"
        query += "?bed ho:placedIn ?room.\n"
        query += "OPTIONAL {\n"
        query += "?bed1 ho:placedIn* ?mid.\n"
        query += "?mid (^ho:placedIn)* ?bed.\n"
        query += "FILTER (!regex(str(?mid), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?bed ho:placedIn ?room.\n"
        query += "?bed1 ho:placedIn ?room1.\n"
        query += "OPTIONAL {?room ?relNX1 ?room1.\n"
        query += "FILTER((str(?relNX1) = \"http://www.semanticweb.org/spatiotemporalHospitalOntology#nextTo\"))}\n"
        query += "OPTIONAL {?room1 ?relNX2 ?room.\n"
        query += "FILTER((str(?relNX2) = \"http://www.semanticweb.org/spatiotemporalHospitalOntology#nextTo\"))}\n"
        query += "OPTIONAL {?room1 ho:placedIn+ ?area1.\n"
        query += "?area1 a ho:Area.}\n"
        query += "OPTIONAL {?room (ho:placedIn)+ ?area.\n"
        query += "?area a ho:Area.}\n"
        query += "FILTER(?area1 != ?area  ||  (isBlank(?area1) && isBlank(?area)))\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?room1 ho:placedIn+ ?area1.\n"
        query += "?area1 a ho:Area.\n"
        query += "?room ho:placedIn+ ?area.\n"
        query += "?area a ho:Area.\n"
        query += "?lz ho:hasArea ?area1.\n"
        query += "?lz ho:hasArea ?area.\n"
        query += "FILTER(?area1 != ?area)\n"
        query += "}\n"
        query += "OPTIONAL {\n"
        query += "?ev1 ho:hasHospUnit ?huA.\n"
        query += "?ev ho:hasHospUnit ?huA.\n"
        query += "}\n"
        query += "FILTER(!isBlank(?mid)  ||  !isBlank(?relNX1)  ||  !isBlank(?relNX2)  ||  !isBlank(?lz)  ||  !isBlank(?huA))\n"
        query += "FILTER(?p != ?p1)\n"
        query += "FILTER((?tm_start >= ?start) && (?tm_end <= ?end))\n"
        query += "FILTER((?ev_start >= ?start && ?ev_end <= ?end)\n"
        query += "|| (?ev_start <= ?start && ?ev_end >= ?start)\n"
        query += "|| (?ev_start <= ?end && ?ev_end >= ?end))\n"
        query += "FILTER((?ev1_start >= ?start && ?ev1_end <= ?end)\n"
        query += "|| (?ev1_start <= ?start && ?ev1_end >= ?start)\n"
        query += "|| (?ev1_start <= ?end && ?ev1_end >= ?end))\n"
        query += "}\n"
        query += "UNION\n"
        query += "{\n"
        query += "SELECT ?bed ?bed1 (group_concat(DISTINCT ?mid; separator=\", \") AS ?pathToMiddleLoc) (group_concat(DISTINCT ?mid2; separator=\", \") AS ?pathToMiddleLoc2)\n"
        query += "{\n"
        query += "{\n"
        query += "SELECT DISTINCT ?bed ?bed1 {\n"
        query += "VALUES (?start ?end) {{(\"{}\"^^xsd:dateTime \"{}\"^^xsd:dateTime)}}".format(self.dateStart, self.dateEnd)
        query += "VALUES (?m_id ?p1_id) {{({} {})}}".format(self.idBact, self.idPat)
        query += "?p1 a ho:Patient;\n"
        query += "ho:id ?p1_id .\n"
        query += "?ev1 ho:eventFromEpisode/ho:episodeFromPatient ?p1;\n"
        query += "ho:start ?ev1_start;\n"
        query += "ho:end ?ev1_end;\n"
        query += "ho:hasLocation ?bed1.\n"
        query += "?m a ho:Microorganism;\n"
        query += "ho:id ?m_id .\n"
        query += "?tm ho:hasFound ?m;\n"
        query += "ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?tm_start;\n"
        query += "ho:end ?tm_end.\n"
        query += "?ep ho:episodeFromPatient ?p .\n"
        query += "?ev ho:eventFromEpisode ?ep ;\n"
        query += "ho:start ?ev_start;\n"
        query += "ho:end ?ev_end;\n"
        query += "ho:hasLocation ?bed.\n"
        query += "FILTER(?p != ?p1)\n"
        query += "FILTER((?tm_start >= ?start) && (?tm_end <= ?end))\n"
        query += "FILTER((?ev_start >= ?start && ?ev_end <= ?end)\n"
        query += "|| (?ev_start <= ?start && ?ev_end >= ?start)\n"
        query += "|| (?ev_start <= ?end && ?ev_end >= ?end))\n"
        query += "FILTER((?ev1_start >= ?start && ?ev1_end <= ?end)\n"
        query += "|| (?ev1_start <= ?start && ?ev1_end >= ?start)\n"
        query += "|| (?ev1_start <= ?end && ?ev1_end >= ?end))\n"
        query += "}\n"
        query += "}\n"
        query += "?bed1 ho:placedIn* ?mid.\n"
        query += "?mid ho:placedIn* ?midAux.\n"
        query += "?midAux (^ho:placedIn)+ ?mid2.\n"
        query += "?mid2 (^ho:placedIn)* ?bed.\n"
        query += "FILTER (!regex(str(?mid), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "FILTER (!regex(str(?midAux), \"http://www.semanticweb.org/spatiotemporalHospitalOntology#(Floor|Building)/.+\"))\n"
        query += "} GROUP BY ?bed ?bed1\n"
        query += "}\n"
        query += "}"

        return query

	
	 
		 
		
